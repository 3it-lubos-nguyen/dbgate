<script lang="ts">
  import { createPerspectiveNodeConfig, MultipleDatabaseInfo, PerspectiveConfig } from 'dbgate-datalib';
  import _ from 'lodash';
  import { tick } from 'svelte';
  import runCommand from '../commands/runCommand';

  import Designer from '../designer/Designer.svelte';
  import QueryDesignerReference from '../designer/QueryDesignerReference.svelte';

  export let config: PerspectiveConfig;
  export let dbInfos: MultipleDatabaseInfo;

  export let conid;
  export let database;

  export let onChange;

  function createDesignerModel(config: PerspectiveConfig, dbInfos: MultipleDatabaseInfo) {
    return {
      ...config,
      tables: _.compact(
        config.nodes.map(node => {
          const table = dbInfos?.[node.conid || conid]?.[node.database || database]?.tables?.find(
            x => x.pureName == node.pureName && x.schemaName == node.schemaName
          );
          if (!table) return null;

          const { designerId } = node;
          return {
            ...table,
            left: node?.position?.x || 0,
            top: node?.position?.y || 0,
            designerId,
          };
        })
      ),
    };
  }

  function handleChange(value, skipUndoChain, settings) {
    onChange(oldValue => {
      const newValue = _.isFunction(value) ? value(createDesignerModel(oldValue, dbInfos)) : value;
      let isArranged = oldValue.isArranged;
      if (settings?.isCalledFromArrange) {
        isArranged = true;
      }
      const res = {
        ...oldValue,
        references: newValue.references,
        nodes: _.compact(
          oldValue.nodes.map(node => {
            const table = newValue.tables?.find(x => x.designerId == node.designerId);

            if (!table && settings?.removeTables) {
              return null;
            }

            const nodeChanged = {
              ...node,
              alias: table?.alias,
            };
            if (table && (table.left != node.position?.x || table.top != node.position?.y)) {
              if (!settings?.isCalledFromArrange) {
                isArranged = false;
              }
              nodeChanged.position = { x: table.left, y: table.top };
            }
            return nodeChanged;
          })
        ),
      };

      for (const table of newValue.tables) {
        if (res.nodes.find(x => x.designerId == table.designerId)) {
          continue;
        }
        const newNode = createPerspectiveNodeConfig(table);
        newNode.designerId = table.designerId;
        newNode.position = { x: table.left, y: table.top };
        isArranged = false;
        res.nodes.push(newNode);
      }

      res.isArranged = isArranged;

      return res;
    });
  }

  async function detectAutoArrange(config: PerspectiveConfig, dbInfos) {
    if (config.isArranged && config.nodes.find(x => !x.position)) {
      await tick();
      runCommand('designer.arrange');
    }
  }

  $: detectAutoArrange(config, dbInfos);
</script>

<Designer
  {...$$props}
  settings={{
    showTableCloseButton: true,
    allowColumnOperations: true,
    allowCreateRefByDrag: true,
    allowScrollColumns: true,
    canSelectColumns: true,
    canCheckTables: true,
    allowTableAlias: true,
    arrangeAlg: 'tree',
    referenceMenu: ({ designer, reference, onChangeReference, onRemoveReference }) => {
      return [{ text: 'Remove', onClick: () => onRemoveReference(reference) }];
    },
    createReferenceText: reference => (reference.isAutoGenerated ? 'FK' : 'Custom'),
    isColumnChecked: (designerId, columnName) => {
      return config.nodes.find(x => x.designerId == designerId)?.checkedColumns?.includes(columnName);
    },
    setColumnChecked: (designerId, columnName, value) => {
      onChange(cfg => ({
        ...cfg,
        nodes: cfg.nodes.map(node =>
          node.designerId == designerId
            ? {
                ...node,
                checkedColumns: value
                  ? [...(node.checkedColumns || []), columnName]
                  : (node.checkedColumns || []).filter(x => x != columnName),
              }
            : node
        ),
      }));
    },
    isTableChecked: designerId => config.nodes?.find(x => x.designerId == designerId)?.isNodeChecked,
    setTableChecked: (designerId, value) => {
      onChange(cfg => ({
        ...cfg,
        nodes: cfg.nodes.map(node =>
          node.designerId == designerId
            ? {
                ...node,
                isNodeChecked: value,
              }
            : node
        ),
      }));
    },
  }}
  referenceComponent={QueryDesignerReference}
  value={createDesignerModel(config, dbInfos)}
  onChange={handleChange}
/>
